//*****************************************************************************
//Title		:PANSFEM2/FEM/Equation/Solid.h
//Author	:Tanabe Yuta
//Date		:2019/10/10
//Copyright	:(C)2019 TanabeYuta
//*****************************************************************************


#pragma once
#include <vector>
#include <cassert>


#include "../../LinearAlgebra/Models/LAOperation.h"


namespace PANSFEM2 {
	//********************TotalLagrange********************
	template<class T>
	void Solid(std::vector<std::vector<T> >& _Ke, std::vector<std::vector<T> >& _x, std::vector<int>& _element, T _E, T _V) {
		//----------接線剛性行列，等価節点内力ベクトルの確保----------
		_Ke = std::vector<std::vector<T> >(3 * _element.size(), std::vector<T>(3 * _element.size(), T()));

		//----------座標行列を求める----------
		std::vector<std::vector<T> > X;
		for (auto nodeid : _element) {
			X.push_back(_x[nodeid]);
		}

		//----------構成則を求める----------
		std::vector<std::vector<T> > C = std::vector<std::vector<T> >(6, std::vector<T>(6));
		C[0][0] = 1.0 - _V;	C[0][1] = _V;		C[0][2] = _V;		C[0][3] = 0.0;					C[0][4] = 0.0;					C[0][5] = 0.0;
		C[1][0] = _V;		C[1][1] = 1.0 - _V;	C[1][2] = _V;		C[1][3] = 0.0;					C[1][4] = 0.0;					C[1][5] = 0.0;
		C[2][0] = _V;		C[2][1] = _V;		C[2][2] = 1.0 - _V;	C[2][3] = 0.0;					C[2][4] = 0.0;					C[2][5] = 0.0;
		C[3][0] = 0.0;		C[3][1] = 0.0;		C[3][2] = 0.0;		C[3][3] = 0.5*(1.0 - 2.0*_V);	C[3][4] = 0.0;					C[3][5] = 0.0;
		C[4][0] = 0.0;		C[4][1] = 0.0;		C[4][2] = 0.0;		C[4][3] = 0.0;					C[4][4] = 0.5*(1.0 - 2.0*_V);	C[4][5] = 0.0;
		C[5][0] = 0.0;		C[5][1] = 0.0;		C[5][2] = 0.0;		C[5][3] = 0.0;					C[5][4] = 0.0;					C[5][5] = 0.5*(1.0 - 2.0*_V);
		C *= _E / ((1.0 + _V)*(1.0 - 2.0*_V));

		//----------ガウス積分用の定数----------
		std::vector<std::vector<T> > GP = { { -1.0 / sqrt(3.0), -1.0 / sqrt(3.0), -1.0 / sqrt(3.0) },
													{  1.0 / sqrt(3.0), -1.0 / sqrt(3.0), -1.0 / sqrt(3.0) },
													{  1.0 / sqrt(3.0),  1.0 / sqrt(3.0), -1.0 / sqrt(3.0) },
													{ -1.0 / sqrt(3.0),  1.0 / sqrt(3.0), -1.0 / sqrt(3.0) },
													{ -1.0 / sqrt(3.0), -1.0 / sqrt(3.0),  1.0 / sqrt(3.0) },
													{  1.0 / sqrt(3.0), -1.0 / sqrt(3.0),  1.0 / sqrt(3.0) },
													{  1.0 / sqrt(3.0),  1.0 / sqrt(3.0),  1.0 / sqrt(3.0) },
													{ -1.0 / sqrt(3.0),  1.0 / sqrt(3.0),  1.0 / sqrt(3.0) } };
		std::vector<std::vector<T> > GW = { { 1.0, 1.0, 1.0 },
													 { 1.0, 1.0, 1.0 },
													 { 1.0, 1.0, 1.0 },
													 { 1.0, 1.0, 1.0 },
													 { 1.0, 1.0, 1.0 },
													 { 1.0, 1.0, 1.0 },
													 { 1.0, 1.0, 1.0 },
													 { 1.0, 1.0, 1.0 } };

		//----------数値積分ループ内----------
		for (int g = 0; g < 8; g++) {
			//----------形状関数行列を求める----------
			std::vector<std::vector<T> > dNdr = std::vector<std::vector<T> >(3, std::vector<T>(_element.size()));
			dNdr[0][0] = -0.125*(1.0 - GP[g][1])*(1.0 - GP[g][2]);	dNdr[0][1] = 0.125*(1.0 - GP[g][1])*(1.0 - GP[g][2]);	dNdr[0][2] = 0.125*(1.0 + GP[g][1])*(1.0 - GP[g][2]);	dNdr[0][3] = -0.125*(1.0 + GP[g][1])*(1.0 - GP[g][2]);
			dNdr[0][4] = -0.125*(1.0 - GP[g][1])*(1.0 + GP[g][2]);	dNdr[0][5] = 0.125*(1.0 - GP[g][1])*(1.0 + GP[g][2]);	dNdr[0][6] = 0.125*(1.0 + GP[g][1])*(1.0 + GP[g][2]);	dNdr[0][7] = -0.125*(1.0 + GP[g][1])*(1.0 + GP[g][2]);

			dNdr[1][0] = -0.125*(1.0 - GP[g][2])*(1.0 - GP[g][0]);	dNdr[1][1] = -0.125*(1.0 - GP[g][2])*(1.0 + GP[g][0]);	dNdr[1][2] = 0.125*(1.0 - GP[g][2])*(1.0 + GP[g][0]);	dNdr[1][3] = 0.125*(1.0 - GP[g][2])*(1.0 - GP[g][0]);
			dNdr[1][4] = -0.125*(1.0 + GP[g][2])*(1.0 - GP[g][0]);	dNdr[1][5] = -0.125*(1.0 + GP[g][2])*(1.0 + GP[g][0]);	dNdr[1][6] = 0.125*(1.0 + GP[g][2])*(1.0 + GP[g][0]);	dNdr[1][7] = 0.125*(1.0 + GP[g][2])*(1.0 - GP[g][0]);

			dNdr[2][0] = -0.125*(1.0 - GP[g][0])*(1.0 - GP[g][1]);	dNdr[2][1] = -0.125*(1.0 + GP[g][0])*(1.0 - GP[g][1]);	dNdr[2][2] = -0.125*(1.0 + GP[g][0])*(1.0 + GP[g][1]);	dNdr[2][3] = -0.125*(1.0 - GP[g][0])*(1.0 + GP[g][1]);
			dNdr[2][4] = 0.125*(1.0 - GP[g][0])*(1.0 - GP[g][1]);	dNdr[2][5] = 0.125*(1.0 + GP[g][0])*(1.0 - GP[g][1]);	dNdr[2][6] = 0.125*(1.0 + GP[g][0])*(1.0 + GP[g][1]);	dNdr[2][7] = 0.125*(1.0 - GP[g][0])*(1.0 + GP[g][1]);


			//----------座標関連の計算----------
			std::vector<std::vector<T> > dXdr = dNdr * X;
			T J = Determinant3(dXdr);
			std::vector<std::vector<T> > dNdX = Inverse3(dXdr) * dNdr;

			//----------変位勾配テンソルFからひずみ―変位関係行列Bを求める----------
			std::vector<std::vector<T> > B = std::vector<std::vector<T> >(6, std::vector<T>(3 * _element.size()));
			for (int n = 0; n < _element.size(); n++) {
				B[0][3 * n] = dNdX[0][n];	B[0][3 * n + 1] = 0.0;			B[0][3 * n + 2] = 0.0;
				B[1][3 * n] = 0.0;			B[1][3 * n + 1] = dNdX[1][n];	B[1][3 * n + 2] = 0.0;
				B[2][3 * n] = 0.0;			B[2][3 * n + 1] = 0.0;			B[2][3 * n + 2] = dNdX[2][n];
				B[3][3 * n] = dNdX[1][n];	B[3][3 * n + 1] = dNdX[0][n];	B[3][3 * n + 2] = 0.0;
				B[4][3 * n] = 0.0;			B[4][3 * n + 1] = dNdX[2][n];	B[4][3 * n + 2] = dNdX[1][n];
				B[5][3 * n] = dNdX[2][n];	B[5][3 * n + 1] = 0.0;			B[5][3 * n + 2] = dNdX[0][n];
			}

			//----------初期変位マトリクスを求める----------
			_Ke += Transpose(B)*C*B*J*GW[g][0] * GW[g][1] * GW[g][2];
		}
	}
}